#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netdb.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <errno.h>
#include <pthread.h>

#include "standalone.h"
#include "payload_generator.h"

#define RECV_BUFF_SIZE 4096
#define IPH_ID 54321 //IP header identifier for SYN packets
#define SYN_TTL 64   //TTL for SYN packets
#define TCP_WIN_SIZE 65535 //TCP window size for the SYN packets

/** the time that the application would spend to listen for the RST packet for the 
head/tail SYN packets until we consider them lost or never generated by the server */
#define CUTOFF_TIME 60 

struct timespec t_first_SYN_sent = {0};
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int is_server_ready = 0;

struct tcp_pseudo_header {
    u_int32_t src_address;
    u_int32_t dst_address;
    u_int8_t placeholder;
    u_int8_t protocol;
    u_int16_t tcp_length;
	struct tcphdr tcp;
};

/** This function calculates the checksum for a given buffer.
 * 
 * @param buf    The given buffer.
 * @param nwords The number of 16-bit words in the given buffer.
 * @return       The calculated checksum of the buffer.
 */
unsigned short csum(unsigned short *buf, int nwords) {
  unsigned long sum;
  for (sum = 0; nwords > 0; nwords--)
    sum += *buf++;
  sum = (sum >> 16) + (sum & 0xffff);
  sum += (sum >> 16);
  return ~sum;
}

/**
 * This function fills the IP header fields based on the provided configs, protocol, and data size.
 * It sets the appropriate IP version, header length, identification, TTL, etc., and computes
 * the IP header checksum.
 * 
 * @param iphr The IP header structure to be populated.
 * @param configs The configuration structure that contains the client and server IP addr.
 * @param protocol The IP protocol to be used (TCP = 6, UDP = 17).
 * @param data_size The size of the data payload to be sent.
 * 
 * @return 0 on success, -1 if an error occurred.
 */
int populate_ip_header(struct ip *iphr, struct configurations *configs, int protocol, int data_size) {
	iphr->ip_v = 4; //ipv4
	iphr->ip_hl = 5; //set ip header size to be the minimum: 5*4 = 20 bytes
	iphr->ip_tos = 0; //type of service
	iphr->ip_len = iphr->ip_hl * 4 + data_size; //no payload
	iphr->ip_id = htons(IPH_ID); //all datagrams between src and dst of a given protocol must have unique IPv4 ID over a period of MDL
	iphr->ip_off = htons(IP_DF);  //set don't fragment bit
	iphr->ip_ttl = SYN_TTL; //TTL is a single byte, no need to convert endian
	iphr->ip_p = protocol; //tcp is 6, udp is 17
	iphr->ip_sum = 0; //set to 0 before computing the actual checksum later

    // unsigned long src_addr;
    // if (get_host_addr(&src_addr) == -1) return -1; /* get host real ip addr*/
	iphr->ip_src.s_addr = inet_addr(configs->client_ip_addr); /* addr in hostent struct are already in network byte order */
	iphr->ip_dst.s_addr = inet_addr(configs->server_ip_addr); /* inet_addr returns value in network byte order */
	
	// Calculate and set the IP header checksum
    iphr->ip_sum = csum((unsigned short *)iphr, sizeof(struct ip) >> 1);
	
	return 0;
}

/**
 * This function fills the TCP header fields such as source and destination ports, 
 * sequence number, acknowledgment number, flags, window size, and checksum.
 * 
 * @param tcphr The TCP header structure to be populated.
 * @param iphr The corresponding filled IP header structure for the tcp header.
 * @param src_port The source port for the TCP connection.
 * @param dst_port The destination port for the TCP connection.
 */
void populate_tcp_header(struct tcphdr *tcphr, struct ip *iphr, uint16_t src_port, uint16_t dst_port) {
	tcphr->th_sport = htons(src_port);
  	tcphr->th_dport = htons(dst_port);
	tcphr->th_seq = random(); /* start from random sequence number */
	tcphr->th_ack = 0; /* the ack sequence is 0 in the 1st packet */
	tcphr->th_x2 = 0;  /* reserved field */
	tcphr->th_off = 5; /* set the tcp hdr length to be minimum value 20 bytes, as no options */
	tcphr->th_flags = TH_SYN; /* SYN packet */
	tcphr->th_win = htons(TCP_WIN_SIZE); /* max allowed window size, doesn't matter as receiver only sends RST back */
	tcphr->th_sum = 0;
	tcphr->th_urp = 0; /* urgent pointer is not used for this app */

	// Use tcp pseudo header to calculate checksum
	struct tcp_pseudo_header psh;
    // Fill in tcp pseudo header
    psh.src_address = iphr->ip_src.s_addr;  // Source IP address
    psh.dst_address = iphr->ip_dst.s_addr;    // Destination IP address
    psh.placeholder = 0;                        // Reserved, always 0
    psh.protocol = IPPROTO_TCP;                 // Protocol number (TCP = 6)
    psh.tcp_length = htons(sizeof(struct tcphdr)); 
	memcpy(&(psh.tcp), tcphr, sizeof(struct tcphdr));
    
    /* Calculate the checksum and fill it in */
    tcphr->th_sum = csum((unsigned short*)&psh, sizeof(struct tcp_pseudo_header) >> 1);
}

/** 
 * This function populates the IP and TCP headers for a SYN packet, and sends the packet to the server 
 * we want to detect through sock_syn. The function includes all necessary headers and sets the `IP_HDRINCL` 
 * socket option to tell the OS the application will build the IP header.
 * 
 * @param sock_syn The raw socket descriptor used for sending the SYN packet.
 * @param configs The configuration structure containing IP addresses and port information.
 * @param server_port The destination server port for the SYN packet.
 * 
 * @return 0 on success, or -1 if an error occurred (e.g., failure in creating headers, 
 *         sending the packet, or setting socket options).
 */
int send_SYN(int sock_syn, struct configurations *configs, uint16_t server_port) {
	struct ip iphr;
	int res = populate_ip_header(&iphr, configs, IPPROTO_TCP, sizeof(struct tcphdr)); //no payload, data_size is only tcp header size
	if (res == -1) {
		printf("Create ip header failed for tcp SYN \n");
		return -1;
	}

	struct tcphdr tcphr;
	populate_tcp_header(&tcphr, &iphr, configs->client_port_SYN, server_port);
	
	//tcphr.th_sum = tcp_checksum(&tcphr, &iphr, 0); // set checksum in tcp header

	char* buffer = malloc(iphr.ip_len); // initialize buffer for sending
	memcpy(buffer, &iphr, iphr.ip_hl * 4); // copy ip header
	char *tcp_ptr = buffer + iphr.ip_hl * 4;
	memcpy(tcp_ptr, &tcphr, tcphr.th_off * 4); // copy tcp header

	// Set IP_HDRINCL option
	int one = 1;
    res = setsockopt(sock_syn, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one));
    if (res == -1) {
		perror("Failed: Cannot set HDRINCL!");
		return -1;
	}

	// create sin used in sendto func
	struct sockaddr_in sin;
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = inet_addr(configs->server_ip_addr);
	sin.sin_port = htons(server_port);

	// send SYN packet
	res = sendto(sock_syn, buffer, iphr.ip_len, 0, 
		(struct sockaddr *) &sin, sizeof(sin));
	if (res == -1) {
		perror("Failed to send SYN packet");
		return -1;
	}
    free(buffer);
	return 0;
}

/**
 * This function binds the provided socket descriptor to the specified port.
 * 
 * @param fd The socket descriptor that will be bound to the specified port.
 * @param port The port number to bind the socket to.
 * @param addr The sockaddr_in structure that will hold the bound address and port.
 */
void bind_port(int fd, int port, struct sockaddr_in *addr) {
	addr->sin_family = AF_INET;
    addr->sin_addr.s_addr = INADDR_ANY;
    addr->sin_port = htons(port);

	if (bind(fd, (struct sockaddr*) addr, sizeof(struct sockaddr_in)) == -1) {
		perror("Failed to bind socket");
		close(fd);
		exit(EXIT_FAILURE);
	}
}

/**
 * This function sets the TTL (time to live) for the socket, which determines how many 
 * hops the packet can make before being discarded. 
 * 
 * @param fd The socket descriptor on which TTL will be set.
 * @param ttl The TTL value to set for the socket (in the range 0-255).
 */
void set_ttl(int fd, int ttl) {
	int result = setsockopt(fd, IPPROTO_IP, IP_TTL, &ttl, sizeof(ttl));
	if (result == -1) {
		perror("Failed to set ttl");
		close(fd);
		exit(EXIT_FAILURE);
	}
}

/** 
 * Sets the "Don't Fragment" (DF) flag on the socket to prevent packet fragmentation.
 * @param fd The file descriptor of the socket to configure.
 */
void set_df(int fd) {
	int val = IP_PMTUDISC_DO;
	if (setsockopt(fd, IPPROTO_IP, IP_MTU_DISCOVER, &val, sizeof(val)) == -1) {
		perror("Failed to set don't fragment");
		close(fd);
		exit(EXIT_FAILURE);
	}
}

/**
 * This function generates a payload for UDP packets and sends a series of packets 
 * (packet train) to the specified server using the given socket descriptor. The 
 * packet IDs are filled, and each packet is sent in sequence.
 * 
 * @param sock_udp The UDP socket descriptor used to send the packets.
 * @param configs The configuration structure containing packet details such as size and number of packets.
 * @param server_sin The sockaddr_in structure containing the destination server address and port.
 * @param high A flag indicating whether to use high-entropy random data (if set to 1), or low-entropy data (if set to 0).
 * 
 * @return 0 on success, or -1 if an error occurred while sending the packets.
 */
int send_UDP_train(int sock_udp, struct configurations *configs, 
	struct sockaddr_in *server_sin, int high) {
	// Generate udp payload
	unsigned char *payload = generate_payload(configs->l, high);

	// Send packet train
	int count;
	for (int i = 0; i < configs->n; i++) {
		fill_packet_id(payload, i);
		count = sendto(sock_udp, payload, configs->l, 0, (struct sockaddr *) server_sin, sizeof(struct sockaddr_in));
		if (count == -1) {
			perror("Failed to send UDP packet");
			free(payload);
			return -1;
		}
	}
	free(payload); //free allocated resource
	return 0;
}

/**
 * This function performs the following detect tasks:
 * 1. Creates raw TCP socket and normal UDP socket for sending SYN packets and UDP packet trains.
 * 2. Configures the client and server addresses for sending UDP packets.
 * 3. Sends SYN packets at the start (head SYN) and end (tail SYN) of a UDP packet train.
 * 4. Sends UDP packet trains with either low-entropy or high-entropy payloads based on configuration.
 * 5. Waits for an inter-measurement period before sending another round of SYN packets and UDP packet train.
 * 
 * @param arg A pointer to the configuration structure containing settings for the detection process.
 * 
 * @return void. The function terminates the program if an error occurs during socket creation or packet sending.
 */
void send_detect_packets(void *arg) {
	struct configurations *configs = (struct configurations *) arg;

	int sock_syn = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
	if (sock_syn == -1) {
	    perror("SYN raw socket creation failed");
	    exit(EXIT_FAILURE);
	}
	
	int sock_udp = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock_udp == -1) {
		perror("UDP socket creation failed");
		exit(EXIT_FAILURE);
	}

	// Create client and server addr for sending udp train
	struct sockaddr_in client_sin, server_sin;
	memset(&client_sin, 0, sizeof(client_sin));
	memset(&server_sin, 0, sizeof(server_sin));

	in_addr_t server_addr = inet_addr(configs->server_ip_addr);

    server_sin.sin_family = AF_INET; /* address from Internet, IP address specifically */
	server_sin.sin_addr.s_addr = server_addr; /* already in network order */
	server_sin.sin_port = htons(configs->udp_dst_port); /* convert to network order */

	// Specify the port client uses to connect to server
	bind_port(sock_udp, configs->udp_src_port, &client_sin);
	// Set ttl from configs
	set_ttl(sock_udp, configs->ttl);
	// Set DF bit
	set_df(sock_udp);

	// Send head SYN
	int result = send_SYN(sock_syn, configs, configs->server_port_head_SYN);
	if (result == -1) {
		printf("Failed to send head SYN packet \n");
		close(sock_syn);
		close(sock_udp);
	}
	pthread_mutex_lock(&lock); 
	clock_gettime(CLOCK_MONOTONIC, &t_first_SYN_sent); //Start timer as soon as the first SYN is sent
	pthread_mutex_unlock(&lock);

	// Send UDP trains
	result = send_UDP_train(sock_udp, configs, &server_sin, 0);
	if (result == -1) {
		close(sock_syn);
		close(sock_udp);
	}
	// Send tail SYN 
	result = send_SYN(sock_syn, configs, configs->server_port_tail_SYN);
	if (result == -1) {
		close(sock_syn);
		close(sock_udp);
	}

	// Wait for inter-measurement time
	sleep(configs->gamma);

	// Send head SYN
	result = send_SYN(sock_syn, configs, configs->server_port_head_SYN);
	if (result == -1) {
		close(sock_syn);
		close(sock_udp);
	}
	// Send UDP trains
	result = send_UDP_train(sock_udp, configs, &server_sin, 1);
	if (result == -1) {
		close(sock_syn);
		close(sock_udp);
	}
	// Send tail SYN 
	result = send_SYN(sock_syn, configs, configs->server_port_tail_SYN);
	if (result == -1) {
		close(sock_syn);
		close(sock_udp);
	}

	close(sock_syn);
	close(sock_udp);
	printf("Sender thread done \n");
}

/** 
 * This function is the start_routine of sender thread. It waits until the receiver signals that it is ready to receive packets. 
 * Once the receiver is ready, it begins the process of sending detection packets using the `send_detect_packets` function.
 * 
 * @param arg A pointer to the configuration structure containing settings for the detection process.
 * 
 * @return NULL This function does not return a value. It is designed to be run by a thread.
 */
void *start_send(void *arg) {
	pthread_mutex_lock(&lock);
	while (!is_server_ready) {
		pthread_cond_wait(&cond, &lock);
	}
	pthread_mutex_unlock(&lock);
	
	printf("receiver ready, start sending detect packets now... \n");
	send_detect_packets(arg);
	return NULL;
}

/** 
 * This function modify the socket descriptor's flags and set it to non-blocking mode.
 * 
 * @param fd The socket descriptor to modify.
 * @return void. The function exits the program if there is an error when getting or setting the flags.
 */
void set_nonblocking(int fd) {
	int flags = fcntl(fd, F_GETFL, 0);
	if (flags == -1) {
        perror("Failed to get file status flags by fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }
	int result = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
	if (result == -1) {
        perror("Failed to set O_NONBLOCK flag");
		close(fd);
        exit(EXIT_FAILURE);
    }
}

/**
 * This function checks if the received packet is an RST packet from the expected source, 
 * and if so, determines whether it is from the head SYN or tail SYN port.
 * If the packet is not an RST packet or is not from the expected source, the function returns -1.
 * 
 * @param buf The buffer containing the received raw packet.
 * @param configs The configuration structure containing expected IP addr and port info.
 * 
 * @return 
 * -1 if the packet is not a related RST packet.
 * 0 if it is an RST packet from the head SYN port.
 * 1 if it is an RST packet from the tail SYN port.
 */
int parse_recv_packet(unsigned char *buf, struct configurations *configs) {
	struct ip *iph = (struct ip *) buf;
	if (iph->ip_v != 4) {
		printf("ip version unmatch: %d\n", iph->ip_v);
		return -1; //only keep ipv4 
	}
	if (iph->ip_src.s_addr != inet_addr(configs->server_ip_addr)) {
		printf("ip addr unmatch\n");
		return -1;
	} //not from the detecting server we sent SYN to

	struct tcphdr *tcph = (struct tcphdr *) (buf + iph->ip_hl * 4); 
	if (tcph->th_flags & TH_RST == 0) {
		printf("RST bit not set \n");
		return -1;
	} //RST bit not set packet
	
	uint16_t src_port = ntohs(tcph->th_sport);
	if (src_port == configs->server_port_head_SYN) {
		return 0;
	} else if (src_port == configs->server_port_tail_SYN) {
		return 1;
	} else {
		printf("th sport unmatch: %u \n", src_port);
		return -1;
	}
}

/** 
 * This function checks whether the `t_first_SYN_sent` timestamp is non-zero. 
 * If the timestamp is non-zero, it indicates that the first SYN packet has been sent.
 * The function uses a mutex to ensure thread safety when accessing the shared `t_first_SYN_sent`.
 * 
 * @return 1 if the first SYN packet has been sent, 0 if it has not.
 */
int is_first_SYN_sent() {
	pthread_mutex_lock(&lock); //lock before read
	int res = !(t_first_SYN_sent.tv_sec == 0 && t_first_SYN_sent.tv_nsec == 0);
	pthread_mutex_unlock(&lock); //unlock after read
	return res;
}

/** 
 * This function sets the `is_server_ready` flag to `1`, indicating that the receiver is ready to start
 * receiving packets. It then signals the sender thread (using the condition variable) to wake up sender
 * and begin sending the detection packets.
 * 
 * @return void. This function does not return any value.
 */
void wakeup_sender() {
	pthread_mutex_lock(&lock);
	is_server_ready = 1; 
	pthread_cond_signal(&cond);
	pthread_mutex_unlock(&lock);
}

/** 
 * This function is the start_routine of the receiver thread. It performs the following tasks:
 * 1. Creates a raw socket to listen for incoming RST packets.
 * 2. Sets the socket to non-blocking mode.
 * 3. Waits for RST packets from the server, filters the relevant ones, and measures the time difference
 *    between receiving the first and second SYN RST packets.
 * 4. Compares the time difference to detect whether compression is present based on the configured threshold (`tau`).
 * 
 * @param arg A pointer to the configuration structure containing the settings for the detection process.
 * 
 * @return NULL. This function does not return any value and is intended to run in a separate thread.
 */
void *start_recv(void *arg) {
	//sleep(5); //to be deleted
	struct configurations *configs = (struct configurations *) arg;

	int sock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
	if (sock == -1) {
	    perror("RST listener raw socket creation failed");
	    exit(EXIT_FAILURE);
	}

	// Set non-blocking
	set_nonblocking(sock);

	unsigned char buf[RECV_BUFF_SIZE];

	int count;
	struct timespec t_l1, t_ln, t_h1, t_hn, t_curr;
	int head_c = 0, tail_c = 0;
	int flag = 0; //represent if sender has been started
	while (1) {
		// sender addr is sent in to filter the received packets
        count = recvfrom(sock, buf, RECV_BUFF_SIZE, 0, NULL, NULL);
        if (count == -1) {
			if (errno == EAGAIN || errno == EWOULDBLOCK) {
				clock_gettime(CLOCK_MONOTONIC, &t_curr);
				if (!flag) {
					flag = 1;
					wakeup_sender();
				}
				if (is_first_SYN_sent() && t_curr.tv_sec - t_first_SYN_sent.tv_sec > CUTOFF_TIME) {
					printf("Failed to detect due to insufficient information.\n");
					break;
				} else {
					continue; // No data available (non-blocking)
				}
			} else {
				perror("Recvfrom failed");
            	close(sock);
				exit(EXIT_FAILURE);
			}  
        }

		// parse received buffer and filtered out packets 
		int result = parse_recv_packet(buf, configs);
		printf("get a packet, result %d\n", result);
		if (result == 0) {
			if (head_c == 0) clock_gettime(CLOCK_MONOTONIC, &t_l1);
			else clock_gettime(CLOCK_MONOTONIC, &t_ln);
			head_c++;
		} else if (result == 1) {
			if (tail_c == 0) clock_gettime(CLOCK_MONOTONIC, &t_h1);
			else clock_gettime(CLOCK_MONOTONIC, &t_hn);
			tail_c++;
		} else {
			continue;
		}

		if (head_c == 2 && tail_c == 2) {
			printf("Received RST packets done \n");
			break;
		}
	}

	if (head_c == 2 && tail_c == 2) {
		long t_l = (t_ln.tv_sec - t_l1.tv_sec) * 1000L + (t_ln.tv_nsec - t_l1.tv_nsec) / 1000000L;
		long t_h = (t_hn.tv_sec - t_h1.tv_sec) * 1000L + (t_hn.tv_nsec - t_h1.tv_nsec) / 1000000L;
		printf("Time difference %ld\n", t_h - t_l);
		if (t_h - t_l > configs->tau) {
			printf("Compression detected!\n");
		} else {
			printf("No compression was detected.\n");
		}
	}

	close(sock);
	printf("Receiver thread done \n");
	return NULL;
}

/** 
 * This function creates two threads: one for sending detection packets and the other for receiving
 * RST packets. It waits for both threads to complete before complete the process.
 * 
 * @param configs A pointer to the configuration structure containing the necessary settings for the detection process.
 */
void probe(struct configurations *configs) {
	pthread_t sender_thr, listener_thr;
	// create sender thread
	int sender_thr_result = pthread_create(&sender_thr, NULL, start_send, configs);
	if (sender_thr_result != 0) {
		perror("Error occurred when creating sender thread");
		exit(EXIT_FAILURE);
	}

	// create listener thread
	int listener_thr_result = pthread_create(&listener_thr, NULL, start_recv, configs);
	if (listener_thr_result != 0) {
		perror("Error occurred when creating listener thread");
		exit(EXIT_FAILURE);
	}

	// Wait for both of the threads to finish
	pthread_join(sender_thr, NULL);
	pthread_join(listener_thr, NULL);

	printf("Detection completed! \n");
}
